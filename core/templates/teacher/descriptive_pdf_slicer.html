{% extends "teacher/teacher_base.html" %}

{% block title %}Descriptive PDF Slicer - {{ school.name }}{% endblock %}

{% block content %}
<style>
* {
    box-sizing: border-box;
}

.slicer-container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 20px;
}

.header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 30px;
    border-radius: 12px;
    margin-bottom: 30px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
}

.header h1 {
    font-size: 28px;
    font-weight: 700;
    margin-bottom: 8px;
}

.header p {
    opacity: 0.9;
    font-size: 15px;
}

.upload-section {
    background: white;
    padding: 30px;
    border-radius: 12px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.08);
    margin-bottom: 30px;
}

.upload-section h2 {
    font-size: 20px;
    font-weight: 600;
    margin-bottom: 20px;
    color: #2d3748;
}

.form-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 20px;
    margin-bottom: 20px;
}

.form-group {
    display: flex;
    flex-direction: column;
}

.form-group label {
    font-size: 14px;
    font-weight: 600;
    color: #4a5568;
    margin-bottom: 8px;
}

.form-group input,
.form-group select {
    padding: 12px;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    font-size: 14px;
    transition: all 0.2s;
}

.form-group input:focus,
.form-group select:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

.file-input-wrapper {
    position: relative;
    overflow: hidden;
    display: inline-block;
    width: 100%;
}

.file-input-wrapper input[type=file] {
    position: absolute;
    left: -9999px;
}

.file-input-label {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 12px;
    background: #f7fafc;
    border: 2px dashed #cbd5e0;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s;
    font-size: 14px;
    color: #4a5568;
}

.file-input-label:hover {
    background: #edf2f7;
    border-color: #667eea;
}

.file-input-label.has-file {
    background: #e6fffa;
    border-color: #48bb78;
    color: #22543d;
}

.btn {
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    display: inline-flex;
    align-items: center;
    gap: 8px;
}

.btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.btn-primary {
    background: #667eea;
    color: white;
}

.btn-success {
    background: #48bb78;
    color: white;
}

.btn-secondary {
    background: #718096;
    color: white;
}

.btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
}

.info-box {
    background: #ebf8ff;
    border: 2px solid #90cdf4;
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 20px;
}

.info-box h3 {
    font-size: 16px;
    font-weight: 600;
    color: #2c5282;
    margin-bottom: 8px;
}

.info-box ul {
    margin-left: 20px;
    color: #2c5282;
    font-size: 14px;
    line-height: 1.6;
}

#questionsList {
    display: none;
    background: white;
    padding: 30px;
    border-radius: 12px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.08);
}

.question-card {
    background: #f7fafc;
    border: 2px solid #e2e8f0;
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 20px;
    transition: all 0.2s;
}

.question-card:hover {
    border-color: #667eea;
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.1);
}

.question-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
}

.question-title {
    font-size: 18px;
    font-weight: 600;
    color: #2d3748;
}

.question-pages {
    font-size: 14px;
    color: #718096;
}

.preview-container {
    background: white;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 16px;
    max-height: 600px;
    overflow-y: auto;
}

.preview-container img {
    width: 100%;
    height: auto;
    border-radius: 4px;
}

.markscheme-container {
    background: #fffaf0;
    border: 2px solid #fbd38d;
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 16px;
}

.markscheme-container h4 {
    font-size: 14px;
    font-weight: 600;
    color: #744210;
    margin-bottom: 8px;
}

.markscheme-text {
    font-size: 13px;
    color: #744210;
    white-space: pre-wrap;
    font-family: monospace;
    max-height: 200px;
    overflow-y: auto;
}

.question-metadata {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 12px;
    margin-bottom: 16px;
}

.status-badge {
    display: inline-block;
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 600;
}

.status-pending {
    background: #fef3c7;
    color: #92400e;
}

.status-saved {
    background: #d1fae5;
    color: #065f46;
}

.page-indicator {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 4px 10px;
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 6px;
    font-size: 12px;
    color: #4a5568;
}

.green-marker {
    width: 12px;
    height: 12px;
    background: #48bb78;
    border-radius: 2px;
}

.red-marker {
    width: 12px;
    height: 12px;
    background: #f56565;
    border-radius: 2px;
}

.blue-marker {
    width: 12px;
    height: 12px;
    background: #4299e1;
    border-radius: 2px;
}

#loadingIndicator {
    display: none;
    text-align: center;
    padding: 40px;
}

.spinner {
    border: 4px solid #f3f4f6;
    border-top: 4px solid #667eea;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    animation: spin 1s linear infinite;
    margin: 0 auto 16px;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}
</style>

<div class="slicer-container">
    <div class="header">
        <h1>üìÑ Descriptive PDF Slicer</h1>
        <p>Process multi-page structured questions with automatic green/red line detection</p>
    </div>

    <div class="upload-section">
        <h2>Upload Paper</h2>

        <div class="info-box">
            <h3>How it works:</h3>
            <ul>
                <li><strong>Green line at top</strong> = Question starts</li>
                <li><strong>Red line at bottom</strong> = Question ends</li>
                <li><strong>Blue lines</strong> = Middle pages (question spanning multiple pages)</li>
                <li>System automatically detects paper component from code (MCQ, Theory, Practical, etc.)</li>
                <li>Markscheme extracts all content for theory questions (not just A/B/C/D)</li>
            </ul>
        </div>

        <form id="uploadForm">
            {% csrf_token %}

            <div class="form-grid">
                <div class="form-group">
                    <label>Paper Code *</label>
                    <input type="text" id="paperCode" name="paper_code" placeholder="e.g., 0625_s23_qp_31" required>
                    <small id="paperInfo" style="margin-top: 4px; font-size: 12px; color: #718096;"></small>
                </div>

                <div class="form-group">
                    <label>Grade *</label>
                    <select id="gradeSelect" name="grade_id" required>
                        <option value="">Select Grade</option>
                        {% for grade in grades %}
                        <option value="{{ grade.id }}">{{ grade.name }}</option>
                        {% endfor %}
                    </select>
                </div>

                <div class="form-group">
                    <label>Subject *</label>
                    <select id="subjectSelect" name="subject_id" required>
                        <option value="">Select Subject</option>
                        {% for subject in subjects %}
                        <option value="{{ subject.id }}">{{ subject.name }}</option>
                        {% endfor %}
                    </select>
                </div>

                <div class="form-group">
                    <label>Topic *</label>
                    <select id="topicSelect" name="topic_id" required>
                        <option value="">Select Topic</option>
                        {% for topic in topics %}
                        <option value="{{ topic.id }}">{{ topic.name }}</option>
                        {% endfor %}
                    </select>
                </div>
            </div>

            <div class="form-grid">
                <div class="form-group">
                    <label>Question Paper (PDF) *</label>
                    <div class="file-input-wrapper">
                        <input type="file" id="qpFile" name="qp_file" accept=".pdf" required>
                        <label for="qpFile" class="file-input-label" id="qpLabel">
                            üìÑ Choose QP File
                        </label>
                    </div>
                </div>

                <div class="form-group">
                    <label>Mark Scheme (PDF)</label>
                    <div class="file-input-wrapper">
                        <input type="file" id="msFile" name="ms_file" accept=".pdf">
                        <label for="msFile" class="file-input-label" id="msLabel">
                            üìù Choose MS File (Optional)
                        </label>
                    </div>
                </div>
            </div>

            <button type="submit" class="btn btn-primary" id="uploadBtn">
                üöÄ Process PDF
            </button>
        </form>
    </div>

    <div id="loadingIndicator">
        <div class="spinner"></div>
        <p>Processing PDF... Detecting green/red lines and grouping questions...</p>
    </div>

    <div id="questionsList">
        <h2>Questions Detected</h2>
        <p style="margin-bottom: 20px; color: #718096;">Review and save each question below</p>
        <div id="questionsContainer"></div>
    </div>
</div>

<script>
let pdfData = null;
let paperInfo = null;

// File input handlers
document.getElementById('qpFile').addEventListener('change', function(e) {
    const label = document.getElementById('qpLabel');
    if (e.target.files.length > 0) {
        label.textContent = '‚úì ' + e.target.files[0].name;
        label.classList.add('has-file');
    } else {
        label.textContent = 'üìÑ Choose QP File';
        label.classList.remove('has-file');
    }
});

document.getElementById('msFile').addEventListener('change', function(e) {
    const label = document.getElementById('msLabel');
    if (e.target.files.length > 0) {
        label.textContent = '‚úì ' + e.target.files[0].name;
        label.classList.add('has-file');
    } else {
        label.textContent = 'üìù Choose MS File (Optional)';
        label.classList.remove('has-file');
    }
});

// Paper code info detector
document.getElementById('paperCode').addEventListener('input', function(e) {
    const code = e.target.value;
    const infoEl = document.getElementById('paperInfo');

    if (code.length >= 10) {
        // Try to detect info
        const parts = code.split('_');
        let info = '';

        if (parts[0] === '0625') info += 'Physics';
        else if (parts[0] === '0620') info += 'Chemistry';
        else if (parts[0] === '0610') info += 'Biology';

        if (parts.length > 2) {
            const paperNum = parts[parts.length - 1].replace('.pdf', '');
            if (['11','12','13','21','22','23'].includes(paperNum)) info += ' - MCQ';
            else if (['31','32','33','41','42','43'].includes(paperNum)) info += ' - Theory';
            else if (['51','52','53'].includes(paperNum)) info += ' - Practical';
            else if (['61','62','63'].includes(paperNum)) info += ' - Alt. to Practical';
        }

        if (info) {
            infoEl.textContent = '‚úì Detected: ' + info;
            infoEl.style.color = '#48bb78';
        }
    } else {
        infoEl.textContent = '';
    }
});

// Form submission
document.getElementById('uploadForm').addEventListener('submit', async function(e) {
    e.preventDefault();

    const formData = new FormData(this);
    formData.append('action', 'upload_pdf');

    document.getElementById('loadingIndicator').style.display = 'block';
    document.getElementById('questionsList').style.display = 'none';
    document.getElementById('uploadBtn').disabled = true;

    try {
        const response = await fetch('', {
            method: 'POST',
            headers: {
                'X-CSRFToken': '{{ csrf_token }}'
            },
            body: formData
        });

        const data = await response.json();

        if (data.success) {
            pdfData = data;
            paperInfo = data.paper_info;
            renderQuestions(data.questions_grouped, data.markscheme_data);
        } else {
            alert('Error: ' + (data.error || 'Failed to process PDF'));
        }
    } catch (error) {
        console.error('Error:', error);
        alert('Error processing PDF. Please try again.');
    } finally {
        document.getElementById('loadingIndicator').style.display = 'none';
        document.getElementById('uploadBtn').disabled = false;
    }
});

function renderQuestions(questions, markscheme) {
    const container = document.getElementById('questionsContainer');
    container.innerHTML = '';

    questions.forEach((question, index) => {
        const card = createQuestionCard(question, markscheme, index);
        container.appendChild(card);
    });

    document.getElementById('questionsList').style.display = 'block';
}

function createQuestionCard(question, markscheme, index) {
    const card = document.createElement('div');
    card.className = 'question-card';
    card.id = `question-${index}`;

    const pageCount = question.pages.length;
    const markers = question.pages.map(p => {
        if (p.has_green_line) return '<span class="green-marker"></span>';
        if (p.has_red_line) return '<span class="red-marker"></span>';
        return '<span class="blue-marker"></span>';
    }).join('');

    // Stitch pages for preview
    const stitchedImage = stitchPagesPreview(question.pages);

    // Get markscheme text
    const msText = getMarkschemeForQuestion(question, markscheme);

    card.innerHTML = `
        <div class="question-header">
            <div>
                <div class="question-title">Question ${question.question_number}</div>
                <div class="question-pages">
                    Pages ${question.start_page} - ${question.end_page} (${pageCount} page${pageCount > 1 ? 's' : ''})
                    <span style="margin-left: 8px;">${markers}</span>
                </div>
            </div>
            <span class="status-badge status-pending" id="status-${index}">Pending</span>
        </div>

        <div class="preview-container">
            <img src="${stitchedImage}" alt="Question ${question.question_number}">
        </div>

        ${msText ? `
        <div class="markscheme-container">
            <h4>üìù Mark Scheme</h4>
            <div class="markscheme-text">${msText}</div>
        </div>
        ` : ''}

        <div class="question-metadata">
            <div class="form-group">
                <label>Marks</label>
                <input type="number" id="marks-${index}" value="5" min="1" max="100" style="max-width: 100px;">
            </div>
        </div>

        <button class="btn btn-success" onclick="saveQuestion(${index}, ${question.question_number})">
            üíæ Save Question ${question.question_number}
        </button>
    `;

    return card;
}

function stitchPagesPreview(pages) {
    // For now, just show first page
    // In production, use canvas to stitch vertically
    return pages[0].page_image;
}

function getMarkschemeForQuestion(question, markscheme) {
    if (!markscheme) return '';

    // Get markscheme for the page range
    let msText = '';
    for (let i = question.start_page; i <= question.end_page; i++) {
        if (markscheme[i]) {
            msText += markscheme[i] + '\n';
        }
    }
    return msText.trim();
}

async function saveQuestion(index, questionNumber) {
    const question = pdfData.questions_grouped[index];
    const marks = document.getElementById(`marks-${index}`).value;
    const msText = getMarkschemeForQuestion(question, pdfData.markscheme_data);

    const data = {
        question_number: questionNumber,
        pages: question.pages,
        markscheme: msText,
        grade_id: document.getElementById('gradeSelect').value,
        subject_id: document.getElementById('subjectSelect').value,
        topic_id: document.getElementById('topicSelect').value,
        marks: marks,
        year: paperInfo.year,
        component: paperInfo.component
    };

    try {
        const response = await fetch('', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': '{{ csrf_token }}'
            },
            body: JSON.stringify({
                action: 'save_question',
                ...data
            })
        });

        const result = await response.json();

        if (result.success) {
            const statusBadge = document.getElementById(`status-${index}`);
            statusBadge.textContent = '‚úì Saved';
            statusBadge.className = 'status-badge status-saved';
            alert(`‚úì Question ${questionNumber} saved successfully!`);
        } else {
            alert('Error: ' + (result.error || 'Failed to save question'));
        }
    } catch (error) {
        console.error('Error:', error);
        alert('Error saving question. Please try again.');
    }
}
</script>

{% endblock %}
