{% extends "teacher/teacher_base.html" %}

{% block title %}Descriptive PDF Slicer - {{ school.name }}{% endblock %}

{% block content %}
<style>
* {
    box-sizing: border-box;
}

.slicer-container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 20px;
}

.header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 30px;
    border-radius: 12px;
    margin-bottom: 30px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
}

.header h1 {
    font-size: 28px;
    font-weight: 700;
    margin-bottom: 8px;
}

.header p {
    opacity: 0.9;
    font-size: 15px;
}

.upload-section {
    background: white;
    padding: 30px;
    border-radius: 12px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.08);
    margin-bottom: 30px;
}

.upload-section h2 {
    font-size: 20px;
    font-weight: 600;
    margin-bottom: 20px;
    color: #2d3748;
}

.form-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 20px;
    margin-bottom: 20px;
}

.form-group {
    display: flex;
    flex-direction: column;
}

.form-group label {
    font-size: 14px;
    font-weight: 600;
    color: #4a5568;
    margin-bottom: 8px;
}

.form-group input,
.form-group select {
    padding: 12px;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    font-size: 14px;
    transition: all 0.2s;
}

.form-group input:focus,
.form-group select:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

.file-input-wrapper {
    position: relative;
    overflow: hidden;
    display: inline-block;
    width: 100%;
}

.file-input-wrapper input[type=file] {
    position: absolute;
    left: -9999px;
}

.file-input-label {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 12px;
    background: #f7fafc;
    border: 2px dashed #cbd5e0;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s;
    font-size: 14px;
    color: #4a5568;
}

.file-input-label:hover {
    background: #edf2f7;
    border-color: #667eea;
}

.file-input-label.has-file {
    background: #e6fffa;
    border-color: #48bb78;
    color: #22543d;
}

.btn {
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    display: inline-flex;
    align-items: center;
    gap: 8px;
}

.btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.btn-primary {
    background: #667eea;
    color: white;
}

.btn-success {
    background: #48bb78;
    color: white;
}

.btn-secondary {
    background: #718096;
    color: white;
}

.btn-warning {
    background: #ed8936;
    color: white;
}

.btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
}

.info-box {
    background: #ebf8ff;
    border: 2px solid #90cdf4;
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 20px;
}

.info-box h3 {
    font-size: 16px;
    font-weight: 600;
    color: #2c5282;
    margin-bottom: 8px;
}

.info-box ul {
    margin-left: 20px;
    color: #2c5282;
    font-size: 14px;
    line-height: 1.6;
}

#questionsList {
    display: none;
    background: white;
    padding: 30px;
    border-radius: 12px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.08);
}

.questions-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.questions-header h2 {
    margin: 0;
}

.question-card {
    background: #f7fafc;
    border: 2px solid #e2e8f0;
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 20px;
    transition: all 0.2s;
}

.question-card:hover {
    border-color: #667eea;
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.1);
}

.question-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
}

.question-title {
    font-size: 18px;
    font-weight: 600;
    color: #2d3748;
}

.question-pages {
    font-size: 14px;
    color: #718096;
}

.preview-container {
    background: white;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 16px;
    max-height: 600px;
    overflow-y: auto;
}

.preview-container img {
    width: 100%;
    height: auto;
    border-radius: 4px;
    margin-bottom: 8px;
}

.preview-container img:last-child {
    margin-bottom: 0;
}

.markscheme-container {
    background: #fffaf0;
    border: 2px solid #fbd38d;
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 16px;
}

.markscheme-container h4 {
    font-size: 14px;
    font-weight: 600;
    color: #744210;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
}

.ms-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 13px;
}

.ms-table th,
.ms-table td {
    padding: 8px 12px;
    border: 1px solid #fbd38d;
    text-align: left;
}

.ms-table th {
    background: #fef3c7;
    font-weight: 600;
    color: #744210;
}

.ms-table td {
    background: white;
    color: #744210;
}

.ms-total {
    margin-top: 12px;
    font-weight: 600;
    color: #744210;
    text-align: right;
}

.question-metadata {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 12px;
    margin-bottom: 16px;
}

.status-badge {
    display: inline-block;
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 600;
}

.status-pending {
    background: #fef3c7;
    color: #92400e;
}

.status-saved {
    background: #d1fae5;
    color: #065f46;
}

.page-indicator {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 4px 10px;
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 6px;
    font-size: 12px;
    color: #4a5568;
    margin-right: 4px;
}

.green-marker {
    width: 12px;
    height: 12px;
    background: #48bb78;
    border-radius: 2px;
}

.red-marker {
    width: 12px;
    height: 12px;
    background: #f56565;
    border-radius: 2px;
}

.purple-marker {
    width: 12px;
    height: 12px;
    background: #9f7aea;
    border-radius: 2px;
}

#loadingIndicator {
    display: none;
    text-align: center;
    padding: 40px;
}

.spinner {
    border: 4px solid #f3f4f6;
    border-top: 4px solid #667eea;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    animation: spin 1s linear infinite;
    margin: 0 auto 16px;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.stats-bar {
    display: flex;
    gap: 20px;
    margin-bottom: 20px;
    padding: 15px;
    background: #f0f4f8;
    border-radius: 8px;
}

.stat-item {
    display: flex;
    align-items: center;
    gap: 8px;
}

.stat-value {
    font-size: 24px;
    font-weight: 700;
    color: #2d3748;
}

.stat-label {
    font-size: 13px;
    color: #718096;
}

.no-ms-warning {
    background: #fed7d7;
    border: 1px solid #fc8181;
    color: #c53030;
    padding: 12px;
    border-radius: 8px;
    margin-bottom: 16px;
    font-size: 13px;
}
</style>

<div class="slicer-container">
    <div class="header">
        <h1>üìÑ Descriptive PDF Slicer</h1>
        <p>Process multi-page structured questions with automatic red/green/purple line detection and Cambridge mark scheme parsing</p>
    </div>

    <div class="upload-section">
        <h2>Upload Paper</h2>

        <div class="info-box">
            <h3>How it works:</h3>
            <ul>
                <li><strong>Red line</strong> = New question starts</li>
                <li><strong>Green line</strong> = Sub-part within question</li>
                <li><strong>Purple line</strong> = Answer/working space marker</li>
                <li><strong>Mark Scheme</strong> = Automatically parsed from Cambridge table format (Question | Answer | Marks) starting page 5</li>
                <li>Questions spanning multiple pages are automatically grouped together</li>
            </ul>
        </div>

        <form id="uploadForm">
            {% csrf_token %}

            <div class="form-grid">
                <div class="form-group">
                    <label>Year</label>
                    <input type="number" id="yearInput" name="year" placeholder="e.g., 2023" min="2000" max="2100">
                </div>

                <div class="form-group">
                    <label>Grade *</label>
                    <select id="gradeSelect" name="grade_id" required>
                        <option value="">Select Grade</option>
                        {% for grade in grades %}
                        <option value="{{ grade.id }}">{{ grade.name }}</option>
                        {% endfor %}
                    </select>
                </div>

                <div class="form-group">
                    <label>Subject *</label>
                    <select id="subjectSelect" name="subject_id" required>
                        <option value="">Select Subject</option>
                        {% for subject in subjects %}
                        <option value="{{ subject.id }}">{{ subject.name }}</option>
                        {% endfor %}
                    </select>
                </div>

                <div class="form-group">
                    <label>Topic</label>
                    <select id="topicSelect" name="topic_id">
                        <option value="">Select Topic (Optional)</option>
                        {% for topic in topics %}
                        <option value="{{ topic.id }}">{{ topic.name }}</option>
                        {% endfor %}
                    </select>
                </div>
            </div>

            <div class="form-grid">
                <div class="form-group">
                    <label>Question Paper (PDF) *</label>
                    <div class="file-input-wrapper">
                        <input type="file" id="qpFile" name="qp_file" accept=".pdf" required>
                        <label for="qpFile" class="file-input-label" id="qpLabel">
                            üìÑ Choose Question Paper
                        </label>
                    </div>
                </div>

                <div class="form-group">
                    <label>Mark Scheme (PDF) - Cambridge Format</label>
                    <div class="file-input-wrapper">
                        <input type="file" id="msFile" name="ms_file" accept=".pdf">
                        <label for="msFile" class="file-input-label" id="msLabel">
                            üìù Choose Mark Scheme (Optional)
                        </label>
                    </div>
                </div>
            </div>

            <button type="submit" class="btn btn-primary" id="uploadBtn">
                üöÄ Process PDFs
            </button>
        </form>
    </div>

    <div id="loadingIndicator">
        <div class="spinner"></div>
        <p>Processing PDFs... Detecting colored lines and parsing mark scheme...</p>
    </div>

    <div id="questionsList">
        <div class="questions-header">
            <div>
                <h2>Questions Detected</h2>
                <p style="margin-top: 4px; color: #718096;">Review and save each question below</p>
            </div>
            <button class="btn btn-warning" onclick="saveAllQuestions()">
                üíæ Save All Questions
            </button>
        </div>

        <div class="stats-bar" id="statsBar">
            <div class="stat-item">
                <span class="stat-value" id="totalQuestions">0</span>
                <span class="stat-label">Questions</span>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="totalPages">0</span>
                <span class="stat-label">Pages</span>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="withMarkscheme">0</span>
                <span class="stat-label">With Mark Scheme</span>
            </div>
        </div>

        <div id="questionsContainer"></div>
    </div>
</div>

<script>
let pdfData = null;

// File input handlers
document.getElementById('qpFile').addEventListener('change', function(e) {
    const label = document.getElementById('qpLabel');
    if (e.target.files.length > 0) {
        label.textContent = '‚úì ' + e.target.files[0].name;
        label.classList.add('has-file');
    } else {
        label.textContent = 'üìÑ Choose Question Paper';
        label.classList.remove('has-file');
    }
});

document.getElementById('msFile').addEventListener('change', function(e) {
    const label = document.getElementById('msLabel');
    if (e.target.files.length > 0) {
        label.textContent = '‚úì ' + e.target.files[0].name;
        label.classList.add('has-file');
    } else {
        label.textContent = 'üìù Choose Mark Scheme (Optional)';
        label.classList.remove('has-file');
    }
});

// Form submission
document.getElementById('uploadForm').addEventListener('submit', async function(e) {
    e.preventDefault();

    const formData = new FormData(this);
    formData.append('action', 'upload_pdf');

    document.getElementById('loadingIndicator').style.display = 'block';
    document.getElementById('questionsList').style.display = 'none';
    document.getElementById('uploadBtn').disabled = true;

    try {
        const response = await fetch('', {
            method: 'POST',
            headers: {
                'X-CSRFToken': '{{ csrf_token }}'
            },
            body: formData
        });

        const data = await response.json();

        if (data.success) {
            pdfData = data;
            renderQuestions(data.questions_grouped, data.markscheme_data);
            updateStats(data);
        } else {
            alert('Error: ' + (data.error || 'Failed to process PDF'));
            if (data.traceback) {
                console.error(data.traceback);
            }
        }
    } catch (error) {
        console.error('Error:', error);
        alert('Error processing PDF. Please try again.');
    } finally {
        document.getElementById('loadingIndicator').style.display = 'none';
        document.getElementById('uploadBtn').disabled = false;
    }
});

function updateStats(data) {
    document.getElementById('totalQuestions').textContent = data.total_questions || 0;
    document.getElementById('totalPages').textContent = data.total_pages || 0;

    // Count questions with mark scheme
    let withMs = 0;
    if (data.questions_grouped && data.markscheme_data) {
        data.questions_grouped.forEach(q => {
            if (data.markscheme_data[String(q.question_number)]) {
                withMs++;
            }
        });
    }
    document.getElementById('withMarkscheme').textContent = withMs;
}

function renderQuestions(questions, markscheme) {
    const container = document.getElementById('questionsContainer');
    container.innerHTML = '';

    questions.forEach((question, index) => {
        const card = createQuestionCard(question, markscheme, index);
        container.appendChild(card);
    });

    document.getElementById('questionsList').style.display = 'block';
}

function createQuestionCard(question, markscheme, index) {
    const card = document.createElement('div');
    card.className = 'question-card';
    card.id = `question-${index}`;

    const pageCount = question.pages.length;

    // Create page markers
    const markers = question.pages.map(p => {
        let markerClass = '';
        if (p.has_red_line) markerClass = 'red-marker';
        else if (p.has_green_line) markerClass = 'green-marker';
        else if (p.has_purple_line) markerClass = 'purple-marker';
        return `<span class="page-indicator"><span class="${markerClass}"></span> P${p.page_number}</span>`;
    }).join('');

    // Get mark scheme data for this question
    const msData = markscheme ? markscheme[String(question.question_number)] : null;
    const msHtml = msData ? formatMarkschemeHtml(msData) : '';
    const totalMarks = msData ? msData.total_marks || 0 : 0;

    // Generate images HTML
    const imagesHtml = question.pages.map(p =>
        `<img src="${p.page_image}" alt="Page ${p.page_number}">`
    ).join('');

    card.innerHTML = `
        <div class="question-header">
            <div>
                <div class="question-title">Question ${question.question_number}</div>
                <div class="question-pages">
                    Pages ${question.start_page} - ${question.end_page} (${pageCount} page${pageCount > 1 ? 's' : ''})
                </div>
                <div style="margin-top: 8px;">${markers}</div>
            </div>
            <span class="status-badge status-pending" id="status-${index}">Pending</span>
        </div>

        <div class="preview-container">
            ${imagesHtml}
        </div>

        ${msHtml ? `
        <div class="markscheme-container">
            <h4>üìù Mark Scheme (Auto-parsed from Cambridge Table)</h4>
            ${msHtml}
        </div>
        ` : `
        <div class="no-ms-warning">
            ‚ö†Ô∏è No mark scheme found for this question. Make sure you uploaded the MS PDF and it follows the Cambridge table format.
        </div>
        `}

        <div class="question-metadata">
            <div class="form-group">
                <label>Marks</label>
                <input type="number" id="marks-${index}" value="${totalMarks || 5}" min="1" max="100" style="max-width: 100px;">
            </div>
        </div>

        <button class="btn btn-success" onclick="saveQuestion(${index})">
            üíæ Save Question ${question.question_number}
        </button>
    `;

    return card;
}

function formatMarkschemeHtml(msData) {
    if (!msData) return '';

    let html = '<table class="ms-table"><thead><tr><th>Part</th><th>Answer</th><th>Marks</th></tr></thead><tbody>';

    // Add stem answers first
    if (msData.stem_answers) {
        msData.stem_answers.forEach(entry => {
            if (entry.answer) {
                html += `<tr><td>-</td><td>${escapeHtml(entry.answer)}</td><td>${entry.marks || ''}</td></tr>`;
            }
        });
    }

    // Add part answers
    if (msData.parts) {
        const sortedParts = Object.keys(msData.parts).sort();
        sortedParts.forEach(part => {
            const entries = msData.parts[part];
            entries.forEach((entry, i) => {
                const partLabel = i === 0 ? `(${part})` : '';
                html += `<tr><td>${partLabel}</td><td>${escapeHtml(entry.answer)}</td><td>${entry.marks || ''}</td></tr>`;
            });
        });
    }

    html += '</tbody></table>';
    html += `<div class="ms-total">Total: ${msData.total_marks || 0} marks</div>`;

    return html;
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

async function saveQuestion(index) {
    const question = pdfData.questions_grouped[index];
    const marks = document.getElementById(`marks-${index}`).value;
    const msData = pdfData.markscheme_data ? pdfData.markscheme_data[String(question.question_number)] : null;

    const data = {
        action: 'save_question',
        pages: question.pages,
        markscheme: msData || {},
        grade_id: document.getElementById('gradeSelect').value,
        subject_id: document.getElementById('subjectSelect').value,
        topic_id: document.getElementById('topicSelect').value || null,
        marks: parseInt(marks),
        year: document.getElementById('yearInput').value || null
    };

    try {
        const response = await fetch('', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': '{{ csrf_token }}'
            },
            body: JSON.stringify(data)
        });

        const result = await response.json();

        if (result.success) {
            const statusBadge = document.getElementById(`status-${index}`);
            statusBadge.textContent = '‚úì Saved';
            statusBadge.className = 'status-badge status-saved';
        } else {
            alert('Error: ' + (result.error || 'Failed to save question'));
            if (result.traceback) {
                console.error(result.traceback);
            }
        }
    } catch (error) {
        console.error('Error:', error);
        alert('Error saving question. Please try again.');
    }
}

async function saveAllQuestions() {
    if (!pdfData || !pdfData.questions_grouped) {
        alert('No questions to save');
        return;
    }

    const questions = pdfData.questions_grouped.map((q, index) => {
        const msData = pdfData.markscheme_data ? pdfData.markscheme_data[String(q.question_number)] : null;
        const marks = document.getElementById(`marks-${index}`).value;
        return {
            pages: q.pages,
            markscheme: msData || {},
            marks: parseInt(marks)
        };
    });

    const data = {
        action: 'save_all',
        questions: questions,
        grade_id: document.getElementById('gradeSelect').value,
        subject_id: document.getElementById('subjectSelect').value,
        topic_id: document.getElementById('topicSelect').value || null,
        year: document.getElementById('yearInput').value || null
    };

    try {
        const response = await fetch('', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': '{{ csrf_token }}'
            },
            body: JSON.stringify(data)
        });

        const result = await response.json();

        if (result.success) {
            alert(`‚úì Successfully saved ${result.count} questions!`);
            // Update all status badges
            pdfData.questions_grouped.forEach((q, index) => {
                const statusBadge = document.getElementById(`status-${index}`);
                if (statusBadge) {
                    statusBadge.textContent = '‚úì Saved';
                    statusBadge.className = 'status-badge status-saved';
                }
            });
        } else {
            alert('Error: ' + (result.error || 'Failed to save questions'));
            if (result.traceback) {
                console.error(result.traceback);
            }
        }
    } catch (error) {
        console.error('Error:', error);
        alert('Error saving questions. Please try again.');
    }
}
</script>

{% endblock %}
