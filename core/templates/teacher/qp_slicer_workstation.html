{% load static %}
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>QP Slicer Workstation</title>

<!-- PDF.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

<!-- Fabric.js (drawing tools) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>

<!-- JSZip -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

<style>
:root {
    --primary: #667eea;
    --red: #ef4444;
    --green: #10b981;
    --purple: #8b5cf6;
    --orange: #f59e0b;
    --gray-100: #f3f4f6;
    --gray-200: #e5e7eb;
    --gray-500: #6b7280;
    --gray-600: #4b5563;
    --gray-800: #1f2937;
}

body {
    margin: 0;
    font-family: system-ui, -apple-system, sans-serif;
    overflow: hidden;
}

.container {
    display: flex;
    height: 100vh;
}

/* Sidebar */
#sidebar {
    width: 280px;
    border-right: 1px solid #ccc;
    display: flex;
    flex-direction: column;
    background: white;
}

#sidebar h3 {
    padding: 16px;
    margin: 0;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    font-size: 14px;
}

.upload-section {
    padding: 12px;
    border-bottom: 1px solid #e5e7eb;
}

.upload-section label {
    display: block;
    font-size: 13px;
    font-weight: 600;
    margin-bottom: 6px;
    color: #374151;
}

.upload-section input[type="file"] {
    width: 100%;
    font-size: 12px;
    padding: 6px;
    border: 1px solid #d1d5db;
    border-radius: 4px;
}

.file-label {
    font-size: 11px;
    color: #6b7280;
    margin-top: 4px;
}

#pageList {
    flex: 1;
    overflow: auto;
    padding: 8px;
}

.page-item {
    padding: 8px 12px;
    margin: 4px 0;
    background: white;
    border: 2px solid #e0e0e0;
    border-radius: 6px;
    cursor: pointer;
    font-size: 13px;
    transition: all 0.2s;
}

.page-item:hover {
    background: #f5f5f5;
    border-color: #2563eb;
}

.page-item.active {
    background: #dbeafe;
    border-color: #2563eb;
    font-weight: 600;
}

/* Center */
#center {
    flex: 1;
    display: flex;
    flex-direction: column;
    background: #f9fafb;
}

/* Legend Bar */
.legend-bar {
    padding: 10px 16px;
    background: #f0f4f8;
    border-bottom: 1px solid #e5e7eb;
    display: flex;
    gap: 20px;
    font-size: 12px;
    flex-wrap: wrap;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
}

.legend-color {
    width: 24px;
    height: 4px;
    border-radius: 2px;
}

.legend-color.green { background: var(--green); }
.legend-color.red { background: var(--red); }
.legend-color.purple { background: var(--purple); }
.legend-color.white { background: white; border: 1px solid #ccc; }

#toolbar {
    padding: 12px 16px;
    border-bottom: 1px solid #ddd;
    display: flex;
    gap: 12px;
    align-items: center;
    background: white;
    flex-wrap: wrap;
}

#toolbar button {
    padding: 8px 16px;
    background: #2563eb;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 13px;
    font-weight: 500;
}

#toolbar button:hover {
    background: #1d4ed8;
}

#toolbar button:disabled {
    background: #9ca3af;
    cursor: not-allowed;
}

#toolbar button.success {
    background: #10b981;
}

#toolbar button.success:hover {
    background: #059669;
}

#toolbar button.secondary {
    background: #6b7280;
}

#pageNav {
    display: flex;
    gap: 8px;
    align-items: center;
}

#pageNav button {
    padding: 6px 12px;
    background: #6b7280;
}

#pageNav input {
    width: 60px;
    padding: 6px;
    border: 1px solid #d1d5db;
    border-radius: 4px;
    text-align: center;
}

.help-text {
    font-size: 11px;
    color: #6b7280;
    margin-left: auto;
    background: #fef3c7;
    padding: 6px 10px;
    border-radius: 4px;
    border: 1px solid #fcd34d;
}

#viewer {
    flex: 1;
    background: #e5e7eb;
    overflow: auto;
    padding: 20px;
    display: flex;
    justify-content: center;
}

#canvasContainer {
    position: relative;
    display: inline-block;
    box-shadow: 0 4px 20px rgba(0,0,0,0.15);
}

/* ==================== MODAL STYLES ==================== */
.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 1000;
    overflow: auto;
}

.modal.active {
    display: flex;
    align-items: center;
    justify-content: center;
}

.modal-content {
    background: white;
    border-radius: 12px;
    width: 95%;
    max-width: 1400px;
    max-height: 95vh;
    display: flex;
    flex-direction: column;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
}

.modal-header {
    padding: 16px 24px;
    border-bottom: 1px solid #e5e7eb;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: #f9fafb;
    border-radius: 12px 12px 0 0;
}

.modal-header h2 {
    margin: 0;
    font-size: 18px;
    color: #111827;
}

.modal-close {
    background: none;
    border: none;
    font-size: 28px;
    cursor: pointer;
    color: #6b7280;
    padding: 0;
    width: 32px;
    height: 32px;
}

.modal-close:hover {
    color: #111827;
}

.modal-body {
    flex: 1;
    overflow: auto;
    padding: 20px;
    display: flex;
    gap: 20px;
}

/* Step indicator */
.step-indicator {
    display: flex;
    gap: 8px;
    padding: 12px 24px;
    background: #f3f4f6;
    border-bottom: 1px solid #e5e7eb;
}

.step {
    padding: 8px 16px;
    border-radius: 20px;
    font-size: 13px;
    font-weight: 500;
    background: #e5e7eb;
    color: #6b7280;
    cursor: pointer;
}

.step.active {
    background: var(--primary);
    color: white;
}

.step.completed {
    background: var(--green);
    color: white;
}

/* Question list panel */
.questions-panel {
    width: 280px;
    border-right: 1px solid #e5e7eb;
    overflow-y: auto;
    flex-shrink: 0;
}

.question-thumb {
    padding: 12px;
    border-bottom: 1px solid #e5e7eb;
    cursor: pointer;
    transition: all 0.15s;
}

.question-thumb:hover {
    background: #f3f4f6;
}

.question-thumb.active {
    background: #dbeafe;
    border-left: 3px solid var(--primary);
}

.question-thumb img {
    width: 100%;
    border-radius: 4px;
    border: 1px solid #d1d5db;
}

.question-thumb-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
}

.question-thumb-title {
    font-weight: 600;
    font-size: 13px;
}

.question-thumb-meta {
    font-size: 11px;
    color: #6b7280;
}

.placeholder-count {
    background: var(--orange);
    color: white;
    padding: 2px 8px;
    border-radius: 10px;
    font-size: 11px;
}

/* Editor panel */
.editor-panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-width: 0;
}

.editor-toolbar {
    padding: 12px;
    background: #f9fafb;
    border-bottom: 1px solid #e5e7eb;
    display: flex;
    gap: 12px;
    align-items: center;
    flex-wrap: wrap;
}

.editor-toolbar button {
    padding: 8px 14px;
    border: 1px solid #d1d5db;
    border-radius: 6px;
    background: white;
    cursor: pointer;
    font-size: 13px;
    display: flex;
    align-items: center;
    gap: 6px;
}

.editor-toolbar button:hover {
    background: #f3f4f6;
    border-color: #9ca3af;
}

.editor-toolbar button.active {
    background: var(--primary);
    color: white;
    border-color: var(--primary);
}

.editor-toolbar .divider {
    width: 1px;
    height: 24px;
    background: #d1d5db;
}

.placeholder-label-input {
    padding: 6px 10px;
    border: 1px solid #d1d5db;
    border-radius: 4px;
    width: 80px;
    font-size: 13px;
}

/* Question image canvas */
.question-canvas-container {
    flex: 1;
    overflow: auto;
    background: #e5e7eb;
    padding: 20px;
    display: flex;
    justify-content: center;
    align-items: flex-start;
}

.question-canvas-wrapper {
    position: relative;
    background: white;
    box-shadow: 0 4px 20px rgba(0,0,0,0.15);
}

/* Placeholder markers */
.placeholder-marker {
    position: absolute;
    background: var(--orange);
    color: white;
    padding: 4px 10px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: 600;
    cursor: move;
    user-select: none;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    z-index: 10;
}

.placeholder-marker:hover {
    background: #d97706;
}

.placeholder-marker .delete-btn {
    margin-left: 6px;
    cursor: pointer;
    opacity: 0.7;
}

.placeholder-marker .delete-btn:hover {
    opacity: 1;
}

/* Properties panel */
.properties-panel {
    width: 280px;
    border-left: 1px solid #e5e7eb;
    padding: 16px;
    overflow-y: auto;
    flex-shrink: 0;
}

.properties-panel h3 {
    margin: 0 0 16px 0;
    font-size: 14px;
    color: #374151;
}

.property-group {
    margin-bottom: 16px;
}

.property-group label {
    display: block;
    font-size: 12px;
    font-weight: 600;
    color: #6b7280;
    margin-bottom: 4px;
}

.property-group input,
.property-group select {
    width: 100%;
    padding: 8px;
    border: 1px solid #d1d5db;
    border-radius: 6px;
    font-size: 13px;
}

.placeholders-list {
    margin-top: 20px;
}

.placeholders-list h4 {
    margin: 0 0 12px 0;
    font-size: 13px;
    color: #374151;
}

.placeholder-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 10px;
    background: #f3f4f6;
    border-radius: 6px;
    margin-bottom: 6px;
    font-size: 13px;
}

.placeholder-item .label {
    font-weight: 600;
    color: var(--orange);
}

.placeholder-item .delete {
    color: var(--red);
    cursor: pointer;
    font-size: 16px;
}

/* Modal footer */
.modal-footer {
    padding: 16px 24px;
    border-top: 1px solid #e5e7eb;
    background: #f9fafb;
    display: flex;
    gap: 12px;
    justify-content: space-between;
    flex-wrap: wrap;
    border-radius: 0 0 12px 12px;
}

.modal-footer .form-section {
    display: flex;
    gap: 12px;
    flex: 1;
    flex-wrap: wrap;
}

.modal-footer .form-group {
    flex: 1;
    min-width: 140px;
}

.modal-footer label {
    display: block;
    font-size: 12px;
    font-weight: 600;
    margin-bottom: 4px;
}

.modal-footer select,
.modal-footer input {
    width: 100%;
    padding: 8px;
    border: 1px solid #d1d5db;
    border-radius: 6px;
    font-size: 13px;
}

#importBtn {
    padding: 10px 24px;
    background: #10b981;
    color: white;
    border: none;
    border-radius: 6px;
    font-weight: 600;
    cursor: pointer;
    white-space: nowrap;
}

#importBtn:hover {
    background: #059669;
}

#importBtn:disabled {
    background: #9ca3af;
    cursor: not-allowed;
}

/* Instructions overlay */
.instructions-overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 30px 40px;
    border-radius: 12px;
    text-align: center;
    z-index: 20;
}

.instructions-overlay h3 {
    margin: 0 0 12px 0;
}

.instructions-overlay p {
    margin: 0;
    opacity: 0.9;
    font-size: 14px;
}
</style>

<div class="container">
    <!-- Sidebar -->
    <div id="sidebar">
        <h3>QP Slicer Workstation</h3>

        <div class="upload-section">
            <label>Question Paper (QP)</label>
            <input type="file" id="qpInput" accept="application/pdf">
            <div class="file-label">Upload a PDF to start slicing</div>
        </div>

        <div style="padding: 12px; background: #ecfdf5; margin: 12px; border-radius: 6px; font-size: 11px; color: #065f46;">
            <strong>Line Guide:</strong><br>
            <span style="color: var(--green);">■</span> <b>Z</b> = Question Start<br>
            <span style="color: var(--red);">■</span> <b>X</b> = Question End<br>
            <span style="color: var(--purple);">■</span> <b>W</b> = Skip Area (headers/footers)<br>
            <span style="color: #999;">□</span> <b>A</b> = White Mask
        </div>

        <div id="pageList"></div>
    </div>

    <!-- Center -->
    <div id="center">
        <div class="legend-bar">
            <div class="legend-item">
                <div class="legend-color green"></div>
                <span><strong>Z</strong> = Start</span>
            </div>
            <div class="legend-item">
                <div class="legend-color red"></div>
                <span><strong>X</strong> = End</span>
            </div>
            <div class="legend-item">
                <div class="legend-color purple"></div>
                <span><strong>W</strong> = Skip (header/footer)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color white"></div>
                <span><strong>A</strong> = Mask</span>
            </div>
        </div>

        <div id="toolbar">
            <div id="pageNav">
                <button onclick="prevPage()">◀</button>
                <input id="pageBox" type="number" min="1" value="1">
                <button onclick="nextPage()">▶</button>
            </div>

            <label style="font-size: 13px; display: flex; align-items: center; gap: 6px;">
                <input type="checkbox" id="includeFirst">
                Include page 1
            </label>

            <button onclick="sliceDocument()" class="success">Slice & Configure</button>
            <button onclick="clearLines()" class="secondary">Clear Lines</button>

            <span class="help-text">
                <strong>Keys:</strong> Z=start | X=end | W=skip | A=mask | Del=remove
            </span>
        </div>

        <div id="viewer">
            <div id="canvasContainer">
                <canvas id="canvas"></canvas>
            </div>
        </div>
    </div>
</div>

<!-- Modal for configuring sliced questions -->
<div id="slicesModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Configure Questions (<span id="sliceCount">0</span>)</h2>
            <button class="modal-close" onclick="closeModal()">&times;</button>
        </div>

        <div class="step-indicator">
            <div class="step completed" id="step1">1. Sliced</div>
            <div class="step active" id="step2">2. Add Answer Placeholders</div>
            <div class="step" id="step3">3. Save</div>
        </div>

        <div class="modal-body">
            <!-- Questions list -->
            <div class="questions-panel" id="questionsPanel"></div>

            <!-- Editor -->
            <div class="editor-panel">
                <div class="editor-toolbar">
                    <button onclick="setPlaceholderMode(true)" id="addPlaceholderBtn">
                        + Add Placeholder
                    </button>
                    <div class="divider"></div>
                    <label style="font-size: 13px;">Label:</label>
                    <input type="text" id="placeholderLabelInput" class="placeholder-label-input" value="(a)" placeholder="(a)">
                    <div class="divider"></div>
                    <label style="font-size: 13px;">Lines:</label>
                    <input type="number" id="placeholderLines" style="width: 60px; padding: 6px; border: 1px solid #d1d5db; border-radius: 4px;" value="3" min="1" max="20">
                    <div class="divider"></div>
                    <span style="font-size: 12px; color: #6b7280;">Click on image to place answer field</span>
                </div>

                <div class="question-canvas-container" id="questionCanvasContainer">
                    <div class="question-canvas-wrapper" id="questionCanvasWrapper">
                        <img id="questionImage" src="" alt="Question">
                        <div id="placeholdersLayer"></div>
                    </div>
                </div>
            </div>

            <!-- Properties -->
            <div class="properties-panel">
                <h3>Question Properties</h3>

                <div class="property-group">
                    <label>Total Marks</label>
                    <input type="number" id="questionMarks" value="5" min="1" max="100">
                </div>

                <div class="placeholders-list">
                    <h4>Answer Placeholders</h4>
                    <div id="placeholdersList"></div>
                    <p style="font-size: 11px; color: #6b7280; margin-top: 8px;">
                        Click "Add Placeholder" then click on the question image to place answer fields.
                    </p>
                </div>
            </div>
        </div>

        <div class="modal-footer">
            <div class="form-section">
                <div class="form-group">
                    <label>Grade</label>
                    <select id="gradeSelect" required>
                        <option value="">Select Grade</option>
                        {% for grade in grades %}
                        <option value="{{ grade.id }}">{{ grade.name }}</option>
                        {% endfor %}
                    </select>
                </div>

                <div class="form-group">
                    <label>Subject</label>
                    <select id="subjectSelect" required>
                        <option value="">Select Subject</option>
                        {% for subject in subjects %}
                        <option value="{{ subject.id }}">{{ subject.name }}</option>
                        {% endfor %}
                    </select>
                </div>

                <div class="form-group">
                    <label>Year</label>
                    <input type="number" id="yearInput" placeholder="e.g., 2023" min="2000" max="2099">
                </div>
            </div>

            <div style="display: flex; gap: 12px; align-items: flex-end;">
                <button onclick="exportAsZip()" style="background: #6b7280; color: white; padding: 10px 16px; border: none; border-radius: 6px; cursor: pointer;">
                    Export ZIP
                </button>
                <button id="importBtn" onclick="saveQuestions()">
                    Import Questions
                </button>
            </div>
        </div>
    </div>
</div>

<script>
pdfjsLib.GlobalWorkerOptions.workerSrc =
    'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

// ==================== STATE ====================
let qpDoc = null;
let pageNum = 1;
let canvas = new fabric.Canvas('canvas');
let scale = 1.5;

// Lines and masks storage by page
let objectsByPage = {};
let activeRect = null;

// Sliced questions data
let slicedQuestions = []; // Array of { dataUrl, pageStart, pageEnd, placeholders: [] }
let currentQuestionIndex = 0;
let placeholderMode = false;

// Mouse tracking
let pointerX = 0;
let pointerY = 0;

// ==================== FILE LOADING ====================

document.getElementById('qpInput').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const buf = await file.arrayBuffer();
    qpDoc = await pdfjsLib.getDocument(buf).promise;

    pageNum = 1;
    objectsByPage = {};
    slicedQuestions = [];

    renderPageList();
    renderPage();
    autoFillYear(file.name);
});

function autoFillYear(filename) {
    const yearMatch = filename.match(/[_\s]([msw])(\d{2})[_\s]/i);
    if (yearMatch) {
        document.getElementById('yearInput').value = 2000 + parseInt(yearMatch[2]);
    }
}

// ==================== PAGE RENDERING ====================

function renderPageList() {
    const pageList = document.getElementById('pageList');
    pageList.innerHTML = '';
    for (let i = 1; i <= qpDoc.numPages; i++) {
        const div = document.createElement('div');
        div.className = 'page-item';
        div.textContent = `Page ${i}`;
        div.onclick = () => goToPage(i);
        pageList.appendChild(div);
    }
    updatePageListHighlight();
}

function updatePageListHighlight() {
    const items = document.querySelectorAll('.page-item');
    items.forEach((item, i) => {
        item.classList.toggle('active', i + 1 === pageNum);
    });
}

function goToPage(p) {
    pageNum = p;
    renderPage();
}

async function renderPage() {
    if (!qpDoc) return;

    const page = await qpDoc.getPage(pageNum);
    const vp = page.getViewport({ scale });

    const tmp = document.createElement('canvas');
    tmp.width = vp.width;
    tmp.height = vp.height;

    await page.render({
        canvasContext: tmp.getContext('2d'),
        viewport: vp
    }).promise;

    canvas.clear();
    canvas.setWidth(vp.width);
    canvas.setHeight(vp.height);

    canvas.setBackgroundImage(
        new fabric.Image(tmp, { selectable: false }),
        canvas.renderAll.bind(canvas)
    );

    canvas.calcOffset();

    // Create active rect if not exists
    if (!activeRect) {
        activeRect = new fabric.Rect({
            left: 40,
            top: 40,
            width: canvas.width - 80,
            height: canvas.height - 80,
            fill: 'rgba(0,0,255,0.03)',
            stroke: 'blue',
            strokeWidth: 2,
            strokeDashArray: [5, 5]
        });
    }
    canvas.add(activeRect);

    // Restore objects for this page
    if (objectsByPage[pageNum]) {
        objectsByPage[pageNum].forEach(obj => canvas.add(obj));
    }

    document.getElementById('pageBox').value = pageNum;
    document.getElementById('pageBox').max = qpDoc.numPages;
    updatePageListHighlight();
}

// ==================== NAVIGATION ====================

function nextPage() {
    if (qpDoc && pageNum < qpDoc.numPages) {
        pageNum++;
        renderPage();
    }
}

function prevPage() {
    if (pageNum > 1) {
        pageNum--;
        renderPage();
    }
}

document.getElementById('pageBox').addEventListener('change', (e) => {
    const newPage = parseInt(e.target.value);
    if (newPage >= 1 && newPage <= qpDoc.numPages) {
        pageNum = newPage;
        renderPage();
    }
});

// ==================== LINE & MASK CREATION ====================

function makeLine(y, color) {
    return new fabric.Line([0, y, canvas.width, y], {
        stroke: color,
        strokeWidth: 3,
        selectable: true,
        lockScalingY: true,
        hasControls: false,
        lineColor: color
    });
}

function addLine(y, color) {
    const line = makeLine(y, color);
    canvas.add(line);

    if (!objectsByPage[pageNum]) objectsByPage[pageNum] = [];
    objectsByPage[pageNum].push(line);
}

function addMask(x, y) {
    const mask = new fabric.Rect({
        left: x - 20,
        top: y - 15,
        width: 40,
        height: 30,
        fill: 'white',
        stroke: '#ccc',
        strokeWidth: 1,
        selectable: true,
        hasControls: true,
        isMask: true
    });

    canvas.add(mask);

    if (!objectsByPage[pageNum]) objectsByPage[pageNum] = [];
    objectsByPage[pageNum].push(mask);
}

function clearLines() {
    if (objectsByPage[pageNum]) {
        objectsByPage[pageNum].forEach(obj => canvas.remove(obj));
        objectsByPage[pageNum] = [];
    }
}

// ==================== KEYBOARD SHORTCUTS ====================

canvas.on('mouse:move', e => {
    pointerX = e.pointer.x;
    pointerY = e.pointer.y;
});

document.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;

    // Navigation
    if (e.key === 'ArrowRight' && !e.shiftKey) { nextPage(); return; }
    if (e.key === 'ArrowLeft' && !e.shiftKey) { prevPage(); return; }

    // Line shortcuts
    if (e.key === 'z' || e.key === 'Z') { addLine(pointerY, 'green'); return; }
    if (e.key === 'x' || e.key === 'X') { addLine(pointerY, 'red'); return; }
    if (e.key === 'w' || e.key === 'W') { addLine(pointerY, '#8b5cf6'); return; }
    if (e.key === 'a' || e.key === 'A') { addMask(pointerX, pointerY); return; }

    // Object manipulation
    const obj = canvas.getActiveObject();
    if (!obj) return;

    if (e.key === 'ArrowUp') { obj.top -= 2; canvas.renderAll(); }
    if (e.key === 'ArrowDown') { obj.top += 2; canvas.renderAll(); }
    if (e.key === 'Delete' || e.key === 'Backspace') {
        canvas.remove(obj);
        if (objectsByPage[pageNum]) {
            objectsByPage[pageNum] = objectsByPage[pageNum].filter(o => o !== obj);
        }
        e.preventDefault();
    }
});

// ==================== SLICING LOGIC ====================

async function sliceDocument() {
    if (!qpDoc) {
        alert('Please upload a question paper first');
        return;
    }

    slicedQuestions = [];
    const startPage = document.getElementById('includeFirst').checked ? 1 : 2;

    console.log('=== SLICING STARTED ===');

    // Collect all lines across pages
    let allEvents = []; // { page, y, type: 'green'|'red'|'purple', obj }

    for (let p = startPage; p <= qpDoc.numPages; p++) {
        const pageObjects = objectsByPage[p] || [];
        const lines = pageObjects.filter(o => o.type === 'line');

        lines.forEach(line => {
            let type = 'unknown';
            if (line.stroke === 'green') type = 'green';
            else if (line.stroke === 'red') type = 'red';
            else if (line.stroke === '#8b5cf6') type = 'purple';

            allEvents.push({ page: p, y: line.top, type, obj: line });
        });
    }

    // Sort by page, then by y position
    allEvents.sort((a, b) => {
        if (a.page !== b.page) return a.page - b.page;
        return a.y - b.y;
    });

    console.log('All events:', allEvents.map(e => `P${e.page}:${e.type}@${Math.round(e.y)}`));

    if (allEvents.filter(e => e.type === 'green').length === 0) {
        alert('No GREEN (start) lines found!\n\nPress Z to draw green lines marking where each question STARTS.');
        return;
    }

    // Process: capture content between GREEN and RED, skipping PURPLE zones
    let openSegment = null;
    let skipUntilY = null; // If set, skip content until this Y position

    for (let p = startPage; p <= qpDoc.numPages; p++) {
        const page = await qpDoc.getPage(p);
        const vp = page.getViewport({ scale });

        const tmp = document.createElement('canvas');
        const ctx = tmp.getContext('2d');
        tmp.width = vp.width;
        tmp.height = vp.height;

        await page.render({ canvasContext: ctx, viewport: vp }).promise;

        // Apply white masks
        const pageObjects = objectsByPage[p] || [];
        pageObjects.forEach(obj => {
            if (obj.isMask && obj.fill === 'white') {
                ctx.fillStyle = 'white';
                ctx.fillRect(obj.left, obj.top, obj.width * (obj.scaleX || 1), obj.height * (obj.scaleY || 1));
            }
        });

        const left = activeRect ? activeRect.left : 40;
        const width = activeRect ? activeRect.getScaledWidth() : canvas.width - 80;
        const pageTop = activeRect ? activeRect.top : 40;
        const pageBottom = activeRect ? activeRect.top + activeRect.getScaledHeight() : canvas.height - 40;

        // Get events for this page
        const pageEvents = allEvents.filter(e => e.page === p);

        // If continuing from previous page
        if (openSegment && skipUntilY === null) {
            openSegment.startY = pageTop;
        }

        for (const event of pageEvents) {
            const y = event.y;

            if (event.type === 'purple') {
                // PURPLE: Toggle skip mode
                if (skipUntilY === null) {
                    // Start skipping - but first capture content up to here
                    if (openSegment && y > openSegment.startY) {
                        const part = crop(tmp, left, openSegment.startY, width, y - openSegment.startY);
                        openSegment.canvas = stitch(openSegment.canvas, part);
                    }
                    skipUntilY = y; // Will be updated by next purple or end of page
                    console.log(`P${p}: Start skipping at Y=${Math.round(y)}`);
                } else {
                    // End skipping
                    console.log(`P${p}: End skipping at Y=${Math.round(y)}`);
                    if (openSegment) {
                        openSegment.startY = y;
                    }
                    skipUntilY = null;
                }

            } else if (event.type === 'green') {
                // GREEN: Start new question
                // Save previous if exists
                if (openSegment && openSegment.canvas) {
                    slicedQuestions.push({
                        dataUrl: openSegment.canvas.toDataURL(),
                        pageStart: openSegment.pageStart,
                        pageEnd: p,
                        placeholders: [],
                        marks: 5
                    });
                    console.log(`Saved question #${slicedQuestions.length}`);
                }

                openSegment = {
                    canvas: null,
                    startY: y,
                    pageStart: p
                };
                skipUntilY = null;
                console.log(`P${p}: New question starts at Y=${Math.round(y)}`);

            } else if (event.type === 'red') {
                // RED: End question
                if (openSegment && skipUntilY === null) {
                    if (y > openSegment.startY) {
                        const part = crop(tmp, left, openSegment.startY, width, y - openSegment.startY);
                        openSegment.canvas = stitch(openSegment.canvas, part);
                    }

                    if (openSegment.canvas) {
                        slicedQuestions.push({
                            dataUrl: openSegment.canvas.toDataURL(),
                            pageStart: openSegment.pageStart,
                            pageEnd: p,
                            placeholders: [],
                            marks: 5
                        });
                        console.log(`Saved question #${slicedQuestions.length} (ended at Y=${Math.round(y)})`);
                    }
                    openSegment = null;
                }
            }
        }

        // End of page: capture remaining content if segment is open and not skipping
        if (openSegment && skipUntilY === null) {
            if (pageBottom > openSegment.startY) {
                const part = crop(tmp, left, openSegment.startY, width, pageBottom - openSegment.startY);
                openSegment.canvas = stitch(openSegment.canvas, part);
            }
        }

        // Reset skip at end of page (purple zones are per-page)
        skipUntilY = null;
    }

    // Save any remaining open segment
    if (openSegment && openSegment.canvas) {
        slicedQuestions.push({
            dataUrl: openSegment.canvas.toDataURL(),
            pageStart: openSegment.pageStart,
            pageEnd: qpDoc.numPages,
            placeholders: [],
            marks: 5
        });
        console.log(`Saved final question #${slicedQuestions.length}`);
    }

    console.log(`=== SLICING COMPLETE: ${slicedQuestions.length} questions ===`);

    if (slicedQuestions.length === 0) {
        alert('No questions sliced!\n\nMake sure GREEN lines mark question starts and RED lines mark question ends.');
        return;
    }

    // Open modal for placeholder configuration
    currentQuestionIndex = 0;
    renderQuestionsPanel();
    loadQuestionInEditor(0);
    showModal();
}

function crop(src, x, y, w, h) {
    if (h <= 0 || w <= 0) return null;
    const c = document.createElement('canvas');
    c.width = w;
    c.height = h;
    c.getContext('2d').drawImage(src, x, y, w, h, 0, 0, w, h);
    return c;
}

function stitch(a, b) {
    if (!b) return a;
    if (!a) return b;

    const c = document.createElement('canvas');
    c.width = Math.max(a.width, b.width);
    c.height = a.height + b.height;

    const ctx = c.getContext('2d');
    ctx.drawImage(a, 0, 0);
    ctx.drawImage(b, 0, a.height);

    return c;
}

// ==================== MODAL & PLACEHOLDER EDITOR ====================

function showModal() {
    document.getElementById('slicesModal').classList.add('active');
    document.getElementById('sliceCount').textContent = slicedQuestions.length;
}

function closeModal() {
    document.getElementById('slicesModal').classList.remove('active');
    placeholderMode = false;
}

function renderQuestionsPanel() {
    const panel = document.getElementById('questionsPanel');
    panel.innerHTML = '';

    slicedQuestions.forEach((q, i) => {
        const div = document.createElement('div');
        div.className = `question-thumb ${i === currentQuestionIndex ? 'active' : ''}`;
        div.onclick = () => loadQuestionInEditor(i);

        div.innerHTML = `
            <div class="question-thumb-header">
                <span class="question-thumb-title">Question ${i + 1}</span>
                <span class="placeholder-count">${q.placeholders.length} fields</span>
            </div>
            <img src="${q.dataUrl}" alt="Question ${i + 1}">
            <div class="question-thumb-meta">Pages ${q.pageStart}-${q.pageEnd} | ${q.marks} marks</div>
        `;

        panel.appendChild(div);
    });
}

function loadQuestionInEditor(index) {
    currentQuestionIndex = index;
    const q = slicedQuestions[index];

    // Update thumbnails
    document.querySelectorAll('.question-thumb').forEach((el, i) => {
        el.classList.toggle('active', i === index);
    });

    // Load image
    const img = document.getElementById('questionImage');
    img.src = q.dataUrl;
    img.onload = () => {
        renderPlaceholders();
    };

    // Update marks
    document.getElementById('questionMarks').value = q.marks;

    // Render placeholders list
    renderPlaceholdersList();
}

function renderPlaceholders() {
    const layer = document.getElementById('placeholdersLayer');
    layer.innerHTML = '';

    const q = slicedQuestions[currentQuestionIndex];

    q.placeholders.forEach((p, i) => {
        const marker = document.createElement('div');
        marker.className = 'placeholder-marker';
        marker.style.left = p.x + 'px';
        marker.style.top = p.y + 'px';
        marker.innerHTML = `${p.label} <span class="delete-btn" onclick="deletePlaceholder(${i})">×</span>`;
        marker.draggable = true;

        // Make draggable
        marker.onmousedown = (e) => startDragPlaceholder(e, i);

        layer.appendChild(marker);
    });
}

function renderPlaceholdersList() {
    const list = document.getElementById('placeholdersList');
    const q = slicedQuestions[currentQuestionIndex];

    if (q.placeholders.length === 0) {
        list.innerHTML = '<p style="color: #9ca3af; font-size: 12px;">No placeholders yet</p>';
        return;
    }

    list.innerHTML = q.placeholders.map((p, i) => `
        <div class="placeholder-item">
            <span class="label">${p.label}</span>
            <span>${p.lines} lines</span>
            <span class="delete" onclick="deletePlaceholder(${i})">×</span>
        </div>
    `).join('');
}

function setPlaceholderMode(enabled) {
    placeholderMode = enabled;
    document.getElementById('addPlaceholderBtn').classList.toggle('active', enabled);

    if (enabled) {
        document.getElementById('questionCanvasContainer').style.cursor = 'crosshair';
    } else {
        document.getElementById('questionCanvasContainer').style.cursor = 'default';
    }
}

// Click to add placeholder
document.getElementById('questionCanvasContainer').addEventListener('click', (e) => {
    if (!placeholderMode) return;

    const wrapper = document.getElementById('questionCanvasWrapper');
    const rect = wrapper.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const label = document.getElementById('placeholderLabelInput').value || '(a)';
    const lines = parseInt(document.getElementById('placeholderLines').value) || 3;

    slicedQuestions[currentQuestionIndex].placeholders.push({
        label: label,
        x: Math.round(x),
        y: Math.round(y),
        lines: lines
    });

    // Auto-increment label
    autoIncrementLabel();

    renderPlaceholders();
    renderPlaceholdersList();
    renderQuestionsPanel();

    // Stay in placeholder mode for multiple additions
});

function autoIncrementLabel() {
    const input = document.getElementById('placeholderLabelInput');
    const current = input.value;

    // Try to increment: (a) -> (b), (i) -> (ii), (1) -> (2)
    const match = current.match(/\(([a-z]|[ivx]+|\d+)\)/i);
    if (match) {
        const inner = match[1];
        let next;

        if (/^[a-z]$/i.test(inner)) {
            // Letter: a -> b
            next = String.fromCharCode(inner.charCodeAt(0) + 1);
        } else if (/^[ivx]+$/i.test(inner)) {
            // Roman numeral
            const romans = ['i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii', 'viii', 'ix', 'x'];
            const idx = romans.indexOf(inner.toLowerCase());
            next = idx >= 0 && idx < romans.length - 1 ? romans[idx + 1] : inner;
        } else if (/^\d+$/.test(inner)) {
            // Number
            next = String(parseInt(inner) + 1);
        } else {
            next = inner;
        }

        input.value = `(${next})`;
    }
}

function deletePlaceholder(index) {
    slicedQuestions[currentQuestionIndex].placeholders.splice(index, 1);
    renderPlaceholders();
    renderPlaceholdersList();
    renderQuestionsPanel();
}

let dragPlaceholderIndex = null;
let dragOffset = { x: 0, y: 0 };

function startDragPlaceholder(e, index) {
    e.preventDefault();
    dragPlaceholderIndex = index;

    const marker = e.target.closest('.placeholder-marker');
    dragOffset = {
        x: e.clientX - marker.offsetLeft,
        y: e.clientY - marker.offsetTop
    };

    document.addEventListener('mousemove', dragPlaceholder);
    document.addEventListener('mouseup', stopDragPlaceholder);
}

function dragPlaceholder(e) {
    if (dragPlaceholderIndex === null) return;

    const wrapper = document.getElementById('questionCanvasWrapper');
    const rect = wrapper.getBoundingClientRect();

    const x = e.clientX - rect.left - dragOffset.x + 50;
    const y = e.clientY - rect.top - dragOffset.y + 10;

    slicedQuestions[currentQuestionIndex].placeholders[dragPlaceholderIndex].x = Math.round(x);
    slicedQuestions[currentQuestionIndex].placeholders[dragPlaceholderIndex].y = Math.round(y);

    renderPlaceholders();
}

function stopDragPlaceholder() {
    dragPlaceholderIndex = null;
    document.removeEventListener('mousemove', dragPlaceholder);
    document.removeEventListener('mouseup', stopDragPlaceholder);
    renderPlaceholdersList();
}

// Update marks when changed
document.getElementById('questionMarks').addEventListener('change', (e) => {
    slicedQuestions[currentQuestionIndex].marks = parseInt(e.target.value) || 5;
    renderQuestionsPanel();
});

// ==================== SAVE & EXPORT ====================

async function saveQuestions() {
    const gradeId = document.getElementById('gradeSelect').value;
    const subjectId = document.getElementById('subjectSelect').value;
    const year = document.getElementById('yearInput').value;

    if (!gradeId || !subjectId) {
        alert('Please select Grade and Subject');
        return;
    }

    const importBtn = document.getElementById('importBtn');
    importBtn.disabled = true;
    importBtn.textContent = 'Importing...';

    try {
        const response = await fetch('/questions/import-qp-slices/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': '{{ csrf_token }}'
            },
            body: JSON.stringify({
                grade_id: gradeId,
                subject_id: subjectId,
                year: year || null,
                questions: slicedQuestions.map(q => ({
                    image: q.dataUrl,
                    marks: q.marks,
                    placeholders: q.placeholders
                }))
            })
        });

        const data = await response.json();

        if (data.success) {
            alert(`Successfully imported ${data.count} questions!`);
            closeModal();
        } else {
            alert('Error: ' + (data.error || 'Failed to import'));
        }
    } catch (error) {
        alert('Error: ' + error.message);
    } finally {
        importBtn.disabled = false;
        importBtn.textContent = 'Import Questions';
    }
}

async function exportAsZip() {
    if (slicedQuestions.length === 0) {
        alert('No questions to export');
        return;
    }

    const zip = new JSZip();

    slicedQuestions.forEach((q, i) => {
        const data = q.dataUrl.split(',')[1];
        zip.file(`question_${i + 1}.png`, data, { base64: true });

        // Also save placeholder config
        zip.file(`question_${i + 1}_config.json`, JSON.stringify({
            marks: q.marks,
            placeholders: q.placeholders
        }, null, 2));
    });

    const blob = await zip.generateAsync({ type: 'blob' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'sliced_questions.zip';
    a.click();
}

// Close on Escape
document.addEventListener('keydown', e => {
    if (e.key === 'Escape') {
        if (placeholderMode) {
            setPlaceholderMode(false);
        } else if (document.getElementById('slicesModal').classList.contains('active')) {
            closeModal();
        }
    }
});
</script>

</body>
</html>
